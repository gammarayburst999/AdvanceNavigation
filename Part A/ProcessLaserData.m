%Author: <Satish Chandra Verma >
% The LIDAR used for producing the data is a SICK LMS291
%PART A: Feature extraction from LIDAR DATA
%Function for processing individual scans (generated by a laser scanner, aka LIDAR); to detect and
%classify objects of interest (OOI), from the raw measurements provided by the sensor. We consider as OOI any
%highly reflective pixel

%PART B: process the sequence of laser scans (which are contained in the
%input data file) by applying, for each individual scan, the function developed in part A. It will process each
%individual laser scan separately, one by one. For each individual scan it will produce a list of OOIs and their
%associated characteristics.


function ProcessLaserData(file)
global ABCD;            % I use a global variable, to easily share it, in many functions. You may obtain similar functionality using other ways.
ABCD.flagPause=0;
ABCD.endnow=0;
ABCD.fe=1;
if ~exist('file','var'), file ='Laser__2.mat'; end
load(file);
% --------------------------------------
%polar co-ordinate
figure(1) ; clf();
MyGUIHandles1.handle1 = plot(0,0,'b.');      % to be used for showing the laser points
hold on
axis([0,180,0,20]);                          % focuses the plot on this region (of interest, close to the robot)
xlabel('angle (degrees)');
ylabel('range (meters)');
MyGUIHandles1.handle2 = title('');           % create an empty title..
legend('Reflective Pixel')
zoom on ;  grid on;
hold off;
% cartesian: local co-ordinate
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
figure(2);
clf();
MyGUIHandles2.handle1 = plot(0,0,'b.');      % to be used for showing the laser points
hold on
axis([-10,10,0,20]);                          % focuses the plot on this region (of interest, close to the robot)
xlabel('X-axis');
ylabel('Y-axis');
MyGUIHandles2.handle2 = title('');
MyGUIHandles2.handle3 =plot(0,0,'+r');
MyGUIHandles2.handle4 =plot(0,0,'+g','MarkerSize',15);
legend('Reflective Pixel','Highly Reflective Pixel','center of OOI')
% create an empty title..
zoom on ;  grid on;
hold off;
%---------------------------------

disp('Showing laser scans, in POLAR representation');
disp('Yo need to modify this program for showing the data in Cartesian.');
disp('(then the images will make sense, for our brains)');
fprintf('\nThere are [ %d ] laser scans in this dataset (file [%s])\n',dataL.N,file);
uicontrol('Style','pushbutton','String','Pause/Cont.','Position',[10,1,80,20],'Callback',{@MyCallBackA,1});
uicontrol('Style','pushbutton','String','END Now','Position',[90,1,80,20],'Callback',{@MyCallBackA,2});
uicontrol('Style','pushbutton','String','FE on/off','Position',[170,1,80,20],'Callback',{@MyCallBackA,3});

% Now, loop through the avaialable scans..
N = dataL.N;
skip=1;     % in this example I skip some of the laser scans.
i=1;
while 1
    if (ABCD.flagPause), pause(0.2) ; continue ; end
    if i>N, break ;  end
    if (ABCD.endnow), break  ; end
    t =  double(dataL.times(i)-dataL.times(1))/10000;
    scan_i = dataL.Scans(:,i);
    tStart = tic;
    MyProcessingOfScan(scan_i,t,MyGUIHandles1,MyGUIHandles2,i);   % some function to use the data...
    execution_time = toc(tStart);
    fprintf(' Time took to execute the code is  %.5f  seconds \n',execution_time);
    pause(0.01) ;
    i=i+skip;
end
fprintf('\nDONE!\n');
return;
end
%-----------------------------------------
function MyProcessingOfScan(scan,t,mh1,mh2,i)
global ABCD;
%%%%%%%%%%%%%%%%%%%%%%%%-------CARTESIAN--------%%%%%%%%%%%%%%%%%%%%%%%%
mask1FFF = uint16(2^13-1);
maskE000 = bitshift(uint16(7),13)  ;
intensities_01 = bitand(scan,maskE000); % cartesian
ranges_01    = single(bitand(scan,mask1FFF))*0.01; %cartesian
angles_01 = [0:360]'*0.5* pi/180 ;
X_01 = cos(angles_01).*ranges_01;
Y_01 = sin(angles_01).*ranges_01;
ii = find(intensities_01~=0);
set(mh2.handle1,'xdata',X_01,'ydata',Y_01);
set(mh2.handle3,'xdata',X_01(ii),'ydata',Y_01(ii));
counter=0;
%%%%%%%%%%%%%%%%%
if ii>0
    xx2=X_01(ii);% store the x co-ordinates of the high intensity points
    yy2=Y_01(ii);

    xx3=[0;xx2]; %just adding extra variable to start
    yy3=[0;yy2];
    ss=length(xx2);
    xx4=[]; % store the x co-ordinates of the high intensity points atleast 20 cm apart
    yy4=[]; % same as above but for y co-ordinates

    %%%%xxxxxx
    for var=1:(ss-1)
        if(abs(xx3(var+1)-xx3(var))>0.2) % over here the threshold is 20 cm
            xx4=[xx4;xx3(var+1)];
        end
        if(abs(yy3(var+1)-yy3(var))>0.2)
            yy4=[yy4;yy3(var+1)];
        end
    end

    number_of_ooi=length(xx4); % number of ooi
    pos=[]; % there position in actual data
    all_center_01=[]; % all center of the high intensity point x
    all_diameter_01=[]; % all diameter
    all_diameter_x01=[];
    all_center_x01=[];
    all_center_y01=[];
    %same but for y
    all_center_02=[];
    all_diameter_02=[];
    k_all=[];
    A_x=[];
    A_y=[];
    for var2=1:number_of_ooi
        k= find(xx3==xx4(var2));
        pos=[pos;k];
    end

    %%%center calculation
    for var3=1:(length(pos))
        if var3 < length(pos)
            start=pos(var3);
            end2=pos(var3+1)-1;
            A=xx3(start:end2);
            B=yy3(start:end2);
        end
        if var3==length(pos)
            start=pos(var3);
            end2=length(xx3);
            A=xx3(start:end2);
            B=yy3(start:end);
        end
        center=mean(A);
        centery=mean(B);
        diameter_01=(A-center);
        diameter_02=(B-centery);
        d_xy=diameter_01.^2+diameter_02.^2;
        dd_xy=2*sqrt(d_xy);
        max_diameter_01= max(dd_xy);
        %max_diameter_02= max(diameter_02);
        all_diameter_01=[all_diameter_01;max_diameter_01];
        %all_diameter_02=[all_diameter_02;max_diameter_02];
        all_center_01=[all_center_01;center];
        all_center_02=[all_center_02;centery];
    end
  % I have calulated the first hight intensity point and its center than i calculated
  % the nearby low intensity point near the high intensity center and
  % re-calculated the new center
    number_of_center=length(all_center_01);
    ones_xy=ones(1,length(X_01))';
    for var4=1:number_of_center
        d= ((all_center_01(var4)*ones_xy)-X_01).^2 + (all_center_02(var4)*ones_xy-Y_01).^2;
        k5=find(sqrt(d)<0.10); % low intensity point near the high intensity center
        if isempty(k5)
            k6=k5;
        else
            k6=[k5;-1]; %used -1 to sperate the cluster points from each other
        end
        k_all=[k_all;k6];
    end
    var7=1;
    %%%%%%%%%%%%%alll new center
    while var7<(length(k_all))

        if k_all(var7) == -1 % using -1 to sub divide the cluster point
            A_x=[];
            A_y=[];
            var7=var7+1;
        end
        while k_all(var7) ~= -1
            A_x= [A_x;X_01(k_all(var7))];
            A_y= [A_y;Y_01(k_all(var7))];
            var7=var7+1;
        end
        center_x=mean(A_x);
        center_y=mean(A_y);
        diameter_x01=(A_x-center_x);
        diameter_y01=(A_y-center_y);
        d_xy_02=diameter_x01.^2+diameter_y01.^2;
        dd_xy_02=2*sqrt(d_xy_02);
        max_diameter_x01= max(dd_xy_02);
        all_diameter_x01=[all_diameter_x01;max_diameter_x01];
        if max_diameter_x01>0.04 && max_diameter_x01<0.2
            all_center_x01=[all_center_x01;center_x];
            all_center_y01=[all_center_y01;center_y];
        end
    end

    if (ABCD.fe)
        set(mh2.handle4,'xdata',all_center_x01,'ydata',all_center_y01,'Color','green','MarkerSize',17);
    else
        set(mh2.handle4,'xdata',all_center_x01,'ydata',all_center_y01,'Color','white','MarkerSize',0.001);
    end
else
    counter=counter+1;
end
%%%%%%%%%%%%%%%%%%%%%%%%---------------%%%%%%%%%%%%%%%%%%%%%%%%



%%%%%%%%%%%%%%%%%%%%%%%%-------POLAR--------%%%%%%%%%%%%%%%%%%%%%%%%
MaskLow13Bits = uint16(2^13-1); %polar
rangesA = bitand(scan,MaskLow13Bits) ; %%%polar co-ordinate
ranges    = 0.01*double(rangesA);
angles = [0:360]'*0.5 ; %%polar co-ordinate

set(mh1.handle1,'xdata',angles,'ydata',ranges);
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% and some text...
s1= sprintf('Polar: Laser scan # [%d] at time [%.3f] secs',i,t);
s2= sprintf(' Cartesian: Laser scan # [%d] at time [%.3f] secs',i,t);
set(mh1.handle2,'string',s1);
set(mh2.handle2,'string',s2);

% Use Matlab help for learning the functionality of  uint16(), bitand()
% , set( ), sprintf()...

return;
end
% ---------------------------------------
% Callback function. I defined it, and associated it to certain GUI button,
function MyCallBackA(~,~,x)
global ABCD;

if (x==1)
    ABCD.flagPause = ~ABCD.flagPause; %Switch ON->OFF->ON -> and so on.
    return;
end
if (x==2)
    ABCD.endnow = ~ABCD.endnow;

    disp('you pressed "END NOW"');
    uiwait(msgbox('CLOSED'));
    close all;
    % students complete this.
    return;
end
if (x==3)
    ABCD.fe = ~ABCD.fe; %Switch ON->OFF->ON -> and so on.
    return;
end
return;
end
